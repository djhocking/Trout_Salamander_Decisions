---
output: html_document
---

## Salamander Occupancy - Expert Elicitation Manuscript
RMarkdown File

Created by: Rachel Katz (rachelakatz@gmail.com)
Authors: Rachel Katz, Dan Hocking, Evan Grant
Expert Contributors: List here.

Created: Feb 01 2016
Last Updated: April 8 2016

#################### collect and format covariate data from sheds
```{r install libraries,                      echo=FALSE, results='hide'}
library(knitr)
library(xtable)
library(dplyr)
library(tidyr)
library(stringr)
library(RPostgreSQL)
library(DBI)
library(ggplot2)
#library(ggthemes)
library(gridExtra)
library(lme4)
#library(plotly) - create interactive plots?
library(RColorBrewer)
```
```{r connect to db,                          echo=FALSE, results='hide', eval=FALSE}
# load profile locally to play with packrat
source("~/.Rprofile")

# check user name and password
R.home()
print(options('SHEDS_USERNAME'))
print(options('SHEDS_PASSWORD'))

# set connection to database
drv <- dbDriver("PostgreSQL")
con <- dbConnect(drv, dbname='sheds_new', host='osensei.cns.umass.edu', user=getOption('SHEDS_USERNAME'), password=getOption('SHEDS_PASSWORD'))
db <- src_postgres(dbname='sheds_new', host='osensei.cns.umass.edu', port='5432', user=options('SHEDS_USERNAME'), password=options('SHEDS_PASSWORD'))
```
```{r download covariates from db & save,     echo=FALSE, results='hide', eval=FALSE}

# column names: featureid |  variable  | value | zone  | riparian_distance_ft 
# zone = upstream or local
# riparian_distance_ft = 200 or NA
# variable =
# featureid = 
# value = 

# get featureids for the deerfield # code from jeff
tbl_huc12 <- tbl(db, 'catchment_huc12')
df_huc <- tbl_huc12 %>%
     select(huc12, featureid) %>%
     dplyr::mutate(HUC4=substr(huc12, as.integer(1), as.integer(4)),
                   HUC8=substr(huc12, as.integer(1), as.integer(8)),
                   HUC10=substr(huc12, as.integer(1), as.integer(10))) %>%
     dplyr::filter(substr(huc12, as.integer(1), as.integer(8)) == '01080203')
df_huc <- dplyr::collect(df_huc)
head(df_huc)
plot(df_huc$HUC4)  # 1 basin (CT)
plot(df_huc$HUC10) # 5 subwatersheds
plot(df_huc$featureid)
featureids<-c(df_huc$featureid)

# get the covariates for deerfield featureids
tbl_covariates <- tbl(db, 'covariates')
tbl_covariates <- dplyr::filter(tbl_covariates, featureid %in% featureids ) 
#df_cov_long<-dplyr::collect(tbl_covariates) # this takes ~ 201pm-
#df_covariates<-tidyr::spread(df_cov_long,variable,value)
summary(df_covariates)
df_covariates_m<-as.matrix((df_covariates))
df_covariates_m
#write.csv(df_covariates_m,file="df_covariates.csv")

# get featureids for the ct basin 
tbl_huc12_ct <- tbl(db, 'catchment_huc12')
df_huc_ct <- tbl_huc12_ct %>%
     select(huc12, featureid) %>%
     dplyr::mutate(HUC4=substr(huc12, as.integer(1), as.integer(4)),
                   HUC8=substr(huc12, as.integer(1), as.integer(8)),
                   HUC10=substr(huc12, as.integer(1), as.integer(10))) %>%
     dplyr::filter(substr(huc12, as.integer(1), as.integer(4)) == '0108')
df_huc_ct <- dplyr::collect(df_huc_ct)
head(df_huc_ct)
plot(df_huc_ct$HUC4)  # 1 basin (CT)
plot(df_huc_ct$huc12) # 5 subwatersheds
plot(df_huc_ct$featureid)
featureids_ct<-c(df_huc_ct$featureid)

# get covariates for the ct featureids #df_covariates_ct<-tidyr::spread(df_cov_long_ct,variable,value)
#tbl_covariates_ct <- dplyr::filter(tbl_covariates, featureid %in% featureids_ct) 
#df_cov_long_ct<-dplyr::collect(tbl_covariates_ct) # this takes ~ 1300pm-
#summary(df_covariates_ct)
df_covariates_m_ct<-as.matrix((df_covariates_ct))
df_covariates_m_ct
#write.csv(df_covariates_m_ct,file="df_covariates_ct.csv")
```
```{r import covariate data and create cov.df,echo=FALSE, results='hide'}

# import saved covariate data from db
deerfield.cov.data<-read.csv("/Users/katz-umass/github_folder/Trout_Salamander_Decisions/Expert_Elicitation/salamander_elicitation_model/df_covariates.csv",fill=TRUE,header=TRUE)

# replace NA's with -999
deerfield.cov.data[is.na(deerfield.cov.data)] <- -999

# select covariates 
covariates<-deerfield.cov.data %>% 
  select(featureid, AreaSqKM,zone,riparian_distance_ft,ann_tmax_c,forest,aug_prcp_mm,slope_pcnt)
str(covariates)

# subset local data (temp)
cov1<-subset(covariates,zone=="local" & ann_tmax_c > -999)
str(cov1) #1088 catchments
ptd<-ggplot(cov1,aes(cov1$ann_tmax_c)) + geom_histogram(alpha=1,binwidth=.1) + xlim(10,26) + ggtitle("deefield max annual temp")

# subset upstream data (drainage area and precip)
cov2<-subset(covariates, zone=="upstream" & ann_tmax_c > -999)
str(cov2) #1088 catchments
pssd<-ggplot(cov2,aes(AreaSqKM)) + geom_histogram(alpha=1, binwidth=20) + ggtitle("deefield drainage area")
ppd<-ggplot(cov2,aes(aug_prcp_mm)) + geom_histogram(alpha=1, binwidth=1) + ggtitle("deefield drainage area")

# subset local riparian zone data (forest cover)
cov3<-subset(covariates, riparian_distance_ft == 200 & zone=="local")
str(cov3) #1088 catchments
pfd<-ggplot(cov3,aes(cov2$forest)) + geom_histogram(alpha=1, binwidth=1) + ggtitle("deefield riparian forest")

# view plots
grid.arrange(pssd,ptd,ppd,pfd)

# save subset data as cov.df
cov.df<-data.frame(cov1$featureid,cov2$AreaSqKM,cov2$aug_prcp_mm,cov2$AreaSqKM*cov2$aug_prcp_mm,cov1$ann_tmax_c,cov2$ann_tmax_c^2,cov2$forest,cov3$forest)
colnames(cov.df)<-c("featureid","area","prcp","area.prcp","temp","temp2","ufor","rfor")
str(cov.df)

# remove greater than 200km2 drainages
cov.df<-subset(cov.df,cov.df$area <= 200) # 985 catchments
str(cov.df)
plot(cov.df)
```

#################### import and analyze expert data from survey
```{r import expert elicitation data, echo=FALSE, results='hide'}
#import expert data
qall2.data<-read.csv("/Users/katz-umass/github_folder/Trout_Salamander_Decisions/Expert_Elicitation/salamander_elicitation_model/expert_elicitation_questionaire_qall2.csv",stringsAsFactors = TRUE,header=TRUE)
str(qall2.data)

#import bio data
#q1sum.data<-read.csv("/Users/katz-umass/github_folder/Trout_Salamander_Decisions/Expert_Elicitation/salamander_elicitation_model/expert_elicitation_questionaire_q1sum.csv",stringsAsFactors = TRUE,header=TRUE)
#str(q1sum.data)
```
```{r plot expert results,            echo=FALSE, results='hide'}
qall3.data<-subset(qall2.data,expert_ID>=10)
sum<-as.data.frame(summarise(group_by(qall3.data,expert_ID,species,question),median=median(mean_reaches,na.rm=TRUE)))
#sum

# set color palette
colourCount = length(unique(qall3.data$expert_ID))
getPalette = colorRampPalette(brewer.pal(9, "Set1"))
e10="#000000" # black
e11="#666666" # grey
e12="#996633" # brown
e13="#FF0000" # red
e14="#0000FF" # blue
e15="#66FF33" # lime green
e16="#00CC99" # aqua
e17="#660099" # purple
e18="#FF6600" # orange
e19="#336600" # dark green 
e20="#FF00FF" # hot pink
e21="#CCCC00" # yellow
e22="#3399FF" # light blue
e23="#9966FF" # light purple 
e24="#FFCC99" # peach 
e.color<-c(e10,e11,e12,e13,e14,e15,e16,e17,e18,e19,e20,e21,e22,e23,e24)

# plot median values per question by expert
s1a<-ggplot(subset(sum,species=="dfus"),aes(median,interaction(question,expert_ID),col=factor(expert_ID)))+geom_point(size=2)+theme(legend.position="none")+scale_colour_manual(values=e.color) + ggtitle("dfus")+facet_grid(expert_ID~., scales="free")
s1b<-ggplot(subset(sum,species=="dfus"),aes(median,interaction(expert_ID,question),col=factor(expert_ID)))+geom_point(size=2)+theme(legend.position="none")+scale_colour_manual(values=getPalette(colourCount))
s2a<-ggplot(subset(sum,species=="gpor"),aes(median,interaction(question,expert_ID),col=factor(expert_ID)))+geom_point(size=2)+theme(legend.position="none")+scale_colour_manual(values=e.color)+ ggtitle("gpor")+facet_grid(expert_ID~., scales="free")
s2b<-ggplot(subset(sum,species=="gpor"),aes(median,interaction(expert_ID,question),col=factor(expert_ID)))+geom_point(size=2)+theme(legend.position="none")+scale_colour_manual(values=e.color)
s3a<-ggplot(subset(sum,species!="dfus"&species!="gpor"),aes(median,interaction(question,expert_ID),col=factor(expert_ID),shape=factor(species)))+geom_point(size=2)+theme(legend.position="none")+scale_colour_manual(values=e.color)+geom_point(stat="identity")+ ggtitle("ebis + ecir (triangle)")+facet_grid(expert_ID~., scales="free")
s3b<-ggplot(subset(sum,species!="dfus"&species!="gpor"),aes(median,interaction(expert_ID,question),col=factor(expert_ID),shape=factor(species)))+geom_point(size=2)+theme(legend.position="none")+scale_colour_manual(values=e.color)+geom_point(stat="identity")
#grid.arrange(s1a,s1b,ncol=2)
#grid.arrange(s2a,s2b,ncol=2)
#grid.arrange(s3a,s3b,ncol=2)
grid.arrange(s1a,s2a,s3a,ncol=3)

# remove NA's
qall.data<-subset(qall2.data,mean_reaches>=0)
str(qall.data)

# remove NEARMI pre-survey data
qall.data<-subset(qall.data,expert_ID>=10)
str(qall.data)

# subset data for each species
qall.dfus<-subset(qall.data,qall.data$species=="dfus")
qall.gpor<-subset(qall.data,qall.data$species=="gpor")
qall.ebis<-subset(qall.data,qall.data$species=="ebis")
qall.ecir<-subset(qall.data,qall.data$species=="ecir")

########## summary of questions answered by each expert

ggplot(qall.data,aes(expert_ID,interaction(question,species),col=factor(expert_ID)))+geom_point(size=2)+scale_colour_manual(values=e.color) +scale_x_continuous(breaks=unique(qall.data$expert_ID))+facet_grid(species~., scales="free")

ggplot(qall.data,aes(expert_ID,interaction(question,species),col=factor(expert_ID)))+geom_point(size=2)+scale_colour_manual(values=e.color) +scale_x_continuous(breaks=unique(qall.data$expert_ID))+facet_grid(species~.~region, scales="free")

########## plot distribution of responses histogram
h1<-ggplot(qall.dfus, aes(x=mean_reaches))+geom_histogram(aes(x=mean_reaches), colour="black", fill="white",binwidth=5)+geom_vline(aes(xintercept=median(mean_reaches)),color="blue",linetype="dashed",size=1)+geom_vline(aes(xintercept=mean(mean_reaches)),color="red",linetype="dashed",size=1)+ggtitle("dfus")+ylim(0,100)
h2<-ggplot(qall.gpor, aes(x=mean_reaches))+geom_histogram(aes(x=mean_reaches), colour="black", fill="white",binwidth=5)+geom_vline(aes(xintercept=median(mean_reaches)),color="blue",linetype="dashed",size=1)+geom_vline(aes(xintercept=mean(mean_reaches)),color="red",linetype="dashed",size=1)+ggtitle("gpor")+ylim(0,100)
h3<-ggplot(qall.ebis, aes(x=mean_reaches))+geom_histogram(aes(x=mean_reaches), colour="black", fill="white",binwidth=5)+geom_vline(aes(xintercept=median(mean_reaches)),color="blue",linetype="dashed",size=1)+geom_vline(aes(xintercept=mean(mean_reaches)),color="red",linetype="dashed",size=1)+ggtitle("ebis")+ylim(0,100)
h4<-ggplot(qall.ecir, aes(x=mean_reaches))+geom_histogram(aes(x=mean_reaches), colour="black", fill="white",binwidth=5)+geom_vline(aes(xintercept=median(mean_reaches)),color="blue",linetype="dashed",size=1)+geom_vline(aes(xintercept=mean(mean_reaches)),color="red",linetype="dashed",size=1)+ggtitle("ecir")+ylim(0,100)
grid.arrange(h1,h2,h3,h4,ncol=2)


########## check for overall variation among experts (across and within species)
p.exsp<-ggplot(qall.data,aes(y=mean_reaches,x=interaction(expert_ID,species),col=factor(expert_ID))) + geom_boxplot() + ylim(0,100) + theme(axis.text.x=element_text(angle=270)) + ggtitle("expert variation across species")+facet_grid(species~.~region, scales="free")+scale_colour_manual(values=e.color)
p.ex<-ggplot(qall.data,aes(y=mean_reaches,x=expert_ID,group=factor(expert_ID))) + geom_boxplot() + ylim(0,100) + theme(axis.text.x=element_text(angle=270))+ ggtitle("expert variation within species")
#grid.arrange(p.ex,p.exsp)
p.exsp

########## region
m<-subset(qall.data,species %in% c("dfus") & question %in% c("2"))
p2.dfus<-ggplot(subset(qall.data,species %in% c("dfus") & question %in% c("2") ),aes(expert_ID,mean_reaches,col=factor(expert_ID)))+ geom_point(size=3,aes(y=mean_reaches))+ geom_errorbar(size=1,aes(ymin=lower_reaches, ymax=upper_reaches), width=0)+ ylim(0, 100)+ theme(legend.position="none")+ ggtitle("dfus")+ scale_colour_manual(values=e.color[m$expert-9])+ scale_x_continuous(breaks=c(10:22))+geom_text(size=3,aes(label=confidence_reaches),hjust=1.2, vjust=2)

m<-subset(qall.data,species %in% c("gpor") & question %in% c("2"))
p2.gpor<-ggplot(subset(qall.data,species %in% c("gpor") & question %in% c("2") ),aes(expert_ID,mean_reaches,col=factor(expert_ID))) + geom_point(size=3,aes(y=mean_reaches)) + geom_errorbar(size=1,aes(ymin=lower_reaches, ymax=upper_reaches), width=0) + ylim(0, 100) + theme(legend.position="none") + ggtitle("gpor")+scale_colour_manual(values=e.color[m$expert-9]) + scale_x_continuous(breaks=c(10:22))+geom_text(size=3,aes(label=confidence_reaches),hjust=1.2, vjust=2)

m<-subset(qall.data,species!="dfus"&species!="gpor" & question %in% c("2"))
p2.ebis<-ggplot(subset(qall.data,species!="dfus"&species!="gpor"&question %in% c("2") ),aes(expert_ID,mean_reaches,col=factor(expert_ID),shape=factor(species))) + geom_point(size=3,aes(y=mean_reaches)) + geom_errorbar(size=1,aes(ymin=lower_reaches, ymax=upper_reaches), width=0) + ylim(0, 100) + theme(legend.position="none") + ggtitle("ebis + ecir (triangle)")+scale_colour_manual(values=e.color[m$expert-9]) + scale_x_continuous(breaks=c(10:22))+geom_text(size=3,aes(label=confidence_reaches),hjust=1.2, vjust=2)

grid.arrange(p2.dfus,p2.gpor,p2.ebis,ncol=3)

mregion<-subset(qall.data,question %in% c("2"))
pregion<-ggplot(subset(qall.data, question %in% c("2") ),aes(expert_ID,mean_reaches,col=factor(expert_ID)))+ geom_point(size=3,aes(y=mean_reaches))+ geom_errorbar(size=1,aes(ymin=lower_reaches, ymax=upper_reaches), width=0)+ ylim(0, 100)+ theme(legend.position="none")+ ggtitle("average across regions")+ scale_colour_manual(values=unique(e.color[mregion$expert-9]))+ scale_x_continuous(breaks=c(10:22))+geom_text(size=3,aes(label=confidence_reaches),hjust=1.2, vjust=2)+ facet_grid(region~.~species, scales="free")
pregion

########## new region w/ new standardized confidence intervals
# 80% confidence intervals = 
num.rand<-1000
conf.data<-subset(qall.data,lower_reaches>=0)
a<-b<-c<-d<-NULL
for(value in 1:length(conf.data$lower_reaches)){
  a[value]<-as.data.frame(runif(num.rand,conf.data$lower_reaches[value],conf.data$upper_reaches[value]))
  b[value]<-as.data.frame(runif(num.rand,0,100))
}
c<-matrix(rep(NA,length(conf.data$lower_reaches)*200),ncol=length(conf.data$lower_reaches),nrow=num.rand*2)
d<-matrix(rep(NA,length(conf.data$lower_reaches)*num.rand),ncol=length(conf.data$lower_reaches),nrow=num.rand)
conf.in<-conf.data$confidence_reaches
for(value in 1:length(conf.data$lower_reaches)){    
  c[,1:length(conf.data$lower_reaches)]<-c(a[[value]],b[[value]])
  d[(1:500),value]<-sample(a[[value]],num.rand*.5,replace=TRUE)
  d[(501:num.rand),value]<-sample(b[[value]],num.rand*.5,replace=TRUE)
}
new.d<-data.frame(d)
new.mean<-apply(new.d[,1:ncol(new.d)], 2, function(x) mean(x, na.rm=TRUE))
new.sd<-apply(new.d[,1:ncol(new.d)], 2, function(x) sd(x, na.rm=TRUE))
conf.data$new.mean<-new.mean
conf.data$new.sd<-new.sd
ggplot(conf.data,aes(new.mean,mean_reaches))+geom_point()
ggplot(conf.data,aes(new.sd,confidence_reaches))+geom_point()

m<-subset(conf.data,species %in% c("dfus") & question %in% c("2"))
c1.dfus<-ggplot(subset(conf.data,species %in% c("dfus") & question %in% c("2") ),aes(expert_ID,mean_reaches,col=factor(expert_ID)))+ geom_point(size=3,aes(y=mean_reaches))+ geom_errorbar(size=1,aes(ymin=lower_reaches, ymax=upper_reaches), width=0)+ ylim(0, 100)+ theme(legend.position="none")+ ggtitle("dfus")+ scale_colour_manual(values=e.color[m$expert-9])+ scale_x_continuous(breaks=c(10:21))+geom_text(size=3,aes(label=confidence_reaches),hjust=1.2, vjust=2)
c2.dfus<-ggplot(),aes(expert_ID,mean_reaches,col=factor(expert_ID))+ geom_point(size=3,aes(y=mean_reaches))+ geom_errorbar(size=1,aes(ymin=lower_reaches, ymax=upper_reaches), width=0)+ ylim(0, 100)+ theme(legend.position="none")+ ggtitle("dfus")+ scale_colour_manual(values=e.color[m$expert-9])+ scale_x_continuous(breaks=c(10:21))+geom_text(size=3,aes(label=confidence_reaches),hjust=1.2, vjust=2)

########## drainage
mlogd<-subset(qall.data,question %in% c("3"))
plogd<-ggplot(subset(qall.data,question %in% c("3") ), aes(log(drainage_area_sqkm),col=factor(expert_ID))) + geom_point(size=0,aes(y=mean_reaches)) + geom_line(size=.75,aes(y=mean_reaches))+ ylim(0, 100)+ theme(panel.border=element_rect(colour="black",fill=NA,size=1),legend.position="none")+ scale_colour_manual(values=unique(e.color[mlogd$expert_ID-9]))+ facet_grid(region~.~species, scales="free")
plogd

md<-subset(qall.data,question %in% c("3"))
pd<-ggplot(subset(qall.data,question %in% c("3") ), aes(drainage_area_sqkm,col=factor(expert_ID))) + geom_point(size=0,aes(y=mean_reaches)) + geom_line(size=.75,aes(y=mean_reaches))+ ylim(0, 100)+ theme(panel.border=element_rect(colour="black",fill=NA,size=1),legend.position="none")+ scale_colour_manual(values=unique(e.color[md$expert_ID-9]))+ facet_grid(region~.~species, scales="free")
pd
grid.arrange(pd,plogd)

########## temp
mtemp<-subset(qall.data,question %in% c("4"))
ptemp<-ggplot(subset(qall.data,question %in% c("4") ), aes(summer_temp_C,col=factor(expert_ID))) + geom_point(size=0,aes(y=mean_reaches)) + geom_line(size=.75,aes(y=mean_reaches))+ ylim(0, 100) + ggtitle("summer stream temperature") + theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[mtemp$expert_ID-9]))+ facet_grid(region~.~species, scales="free")
ptemp

########## streamflow 
mflow<-subset(qall.data,question %in% c("5")&stream_width_m==2)
pflow<-ggplot(subset(qall.data,question %in% c("5")&stream_width_m==2),aes(flow_year_freq,shape=factor(expert_ID))) + geom_point(size=0,aes(y=mean_reaches)) + geom_line(size=.75,aes(y=mean_reaches,color=factor(expert_ID))) +  ylim(0, 100) +  theme(legend.position="none") + ggtitle("small stream (2-m)")+ scale_colour_manual(values=unique(e.color[mflow$expert_ID-9]))+ facet_grid(flow_type+region~.~species, scales="free")

mflow2<-subset(qall.data,question %in% c("5")&stream_width_m==4)
pflow2<-ggplot(subset(qall.data,question %in% c("5")&stream_width_m==4),aes(flow_year_freq,shape=factor(expert_ID))) + geom_point(size=0,aes(y=mean_reaches)) + geom_line(size=.75,aes(y=mean_reaches,color=factor(expert_ID))) +  ylim(0, 100) +  theme(legend.position="none") + ggtitle("medium stream (4-m)")+ scale_colour_manual(values=unique(e.color[mflow2$expert_ID-9]))+ facet_grid(flow_type+region~.~species, scales="free")

mflow3<-subset(qall.data,question %in% c("5"))
pflow3<-ggplot(subset(qall.data,question %in% c("5")),aes(flow_year_freq,shape=factor(expert_ID))) + geom_point(size=0,aes(y=mean_reaches)) + geom_line(size=.75,aes(y=mean_reaches,color=factor(expert_ID))) +  ylim(0, 100) +  theme(legend.position="none") + ggtitle("streamflow x stream size")+ scale_colour_manual(values=unique(e.color[mflow3$expert_ID-9]))+ facet_grid(flow_type+stream_width_m+region~.~species, scales="free")
pflow3

grid.arrange(pflow,pflow2,ncol=1)

########## riparian and upland forest
mfor<-subset(qall.data,question %in% c("6"))
pfor<-ggplot(subset(qall.data,question %in% c("6")), aes(riparian_forest,col=factor(expert_ID))) + geom_point(size=0,aes(y=mean_reaches)) + geom_line(size=0.75,aes(y=mean_reaches)) + ylim(0, 100) + theme(legend.position="none") + ggtitle("percent forest cover")+ scale_colour_manual(values=unique(e.color[mfor$expert_ID-9]))+ facet_grid(upland_forest~.~region+species, scales="free")
pfor

########## trout presence
mfish<-subset(qall.data,question %in% c("7","2"))
pfish<-ggplot(subset(qall.data,question %in% c("7","2")), aes(expert_ID,mean_reaches,col=factor(expert_ID))) + geom_point(size=2,aes(y=mean_reaches)) + geom_errorbar(size=1, aes(ymin=lower_reaches, ymax=upper_reaches), width=0) + ylim(0, 100) + theme(legend.position="none") + ggtitle("brook trout effect")+ scale_colour_manual(values=unique(e.color[mfish$expert_ID-9]))+ scale_x_continuous(breaks=c(10:24))+geom_text(size=3,aes(label=confidence_reaches),hjust=1.2, vjust=2)+ facet_grid(species~.~expert_ID+trout_presence, scales="free")
pfish

########## salamander presence
pd=position_dodge(width=0.8)  
msald<-subset(qall.data,question %in% c("8","2")&species=="dfus")
psald<-ggplot(subset(qall.data,question %in% c("8","2")&species=="dfus"), aes(sal_other,mean_reaches,col=factor(expert_ID))) + geom_point(aes(y=mean_reaches),position=pd) + geom_errorbar(aes(ymin=lower_reaches, ymax=upper_reaches), width=0, position=pd) + ylim(0, 100) + theme(legend.position="none") + scale_colour_manual(values=unique(e.color[msald$expert_ID-9]))+geom_text(size=3,aes(label=confidence_reaches),hjust=1.2, vjust=2,position=pd)+facet_grid(species~.~region+sal_other,scales="free")
psald

pd=position_dodge(width=0.8)  
msalg<-subset(qall.data,question %in% c("8","2")&species=="gpor")
psalg<-ggplot(subset(qall.data,question %in% c("8","2")&species=="gpor"), aes(sal_other,mean_reaches,col=factor(expert_ID))) + geom_point(aes(y=mean_reaches),position=pd) + geom_errorbar(aes(ymin=lower_reaches, ymax=upper_reaches), width=0, position=pd) + ylim(0, 100) + theme(legend.position="none") + scale_colour_manual(values=unique(e.color[msalg$expert_ID-9]))+geom_text(size=3,aes(label=confidence_reaches),hjust=1.2, vjust=2,position=pd)+facet_grid(species~.~region+sal_other,scales="free")
psalg

pd=position_dodge(width=0.8)  
msale<-subset(qall.data,question %in% c("8","2")&species=="ebis")
psale<-ggplot(subset(qall.data,question %in% c("8","2")&species=="ebis"), aes(sal_other,mean_reaches,col=factor(expert_ID))) + geom_point(aes(y=mean_reaches),position=pd) + geom_errorbar(aes(ymin=lower_reaches, ymax=upper_reaches), width=0, position=pd) + ylim(0, 100) + theme(legend.position="none") + scale_colour_manual(values=unique(e.color[msale$expert_ID-9]))+geom_text(size=3,aes(label=confidence_reaches),hjust=1.2, vjust=2,position=pd)+facet_grid(species~.~region+sal_other,scales="free")
psale

pd=position_dodge(width=0.8)  
msalec<-subset(qall.data,question %in% c("8","2")&species=="ecir")
psalec<-ggplot(subset(qall.data,question %in% c("8","2")&species=="ecir"), aes(sal_other,mean_reaches,col=factor(expert_ID))) + geom_point(aes(y=mean_reaches),position=pd) + geom_errorbar(aes(ymin=lower_reaches, ymax=upper_reaches), width=0, position=pd) + ylim(0, 100) + theme(legend.position="none") + scale_colour_manual(values=unique(e.color[msald$expert_ID-9]))+geom_text(size=3,aes(label=confidence_reaches),hjust=1.2, vjust=2,position=pd)+facet_grid(species~.~region+sal_other,scales="free")
psalec

grid.arrange(psald,psalg,psale,psalec)
```
```{r calculate betas (glmer1 - rand int + slops), echo=FALSE, results='hide'}
# plot correlations among predictor variables
#library(corrgram)
#corrgram(qall.data[,22:27], order=TRUE, lower.panel=panel.shade,upper.panel=panel.pie, text.panel=panel.txt)

# used centered covariates (c.covariate name = baseline - value)
# c.log.drainage 0 = log(2)    (-0.43=0.75km2, +2=200km2)
# c.temp 0 = 0.14 (avg temp)   (-0.04=10C,     +0.12=26C)
# c.flow 0 = 100 (normal flow) (-0.90=dry,     +0.90=wet)
# c.freq 0 = 10 years          (-0.1 0yrs,      0=10yrs)
# c.perc.ripa 0 = 100%         (-1=0%,          0=100%)
# c.perc.upla 0 = 100%         (-1=0%,          0=100%)

######## glmer0 - no random effects
glmer0.dfus<-glm(cbind(qall.dfus$mean_reaches,qall.dfus$failure_reaches) ~ c.log.drainage + I(c.log.drainage^2) + c.temp + c.flow + c.freq + c.perc.ripa*c.perc.upla + trout_presence + ebis_presence + gpor_presence,data = qall.dfus,family=binomial)

glmer0.gpor<-glm(cbind(qall.gpor$mean_reaches,qall.gpor$failure_reaches) ~ c.log.drainage + I(c.log.drainage^2) + c.temp + c.flow + c.freq + c.perc.ripa*c.perc.upla + trout_presence + ebis_presence + dfus_presence,data = qall.gpor,family=binomial)

glmer0.ebis<-glm(cbind(qall.ebis$mean_reaches,qall.ebis$failure_reaches) ~ c.log.drainage + I(c.log.drainage^2) + c.temp + c.flow + c.freq + c.perc.ripa*c.perc.upla + trout_presence + dfus_presence + gpor_presence,data = qall.ebis,family=binomial)

glmer0.ecir<-glm(cbind(qall.ecir$mean_reaches,qall.ecir$failure_reaches) ~ c.log.drainage + I(c.log.drainage^2) + c.temp + c.flow + c.freq + c.perc.ripa*c.perc.upla + trout_presence + dfus_presence + gpor_presence,data = qall.ecir,family=binomial)

# save predicted values and residuals for each species
qall.dfus.norand<-qall.dfus
qall.gpor.norand<-qall.gpor
qall.ebis.norand<-qall.ebis
qall.ecir.norand<-qall.ecir
qall.dfus.norand$pred <- predict(glmer0.dfus,type="response")
qall.dfus.norand$resid<- resid(glmer0.dfus)
qall.ebis.norand$pred <- predict(glmer0.ebis,type="response")
qall.ebis.norand$resid<- resid(glmer0.ebis)
qall.ecir.norand$pred <- predict(glmer0.ecir,type="response")
qall.ecir.norand$resid<- resid(glmer0.ecir)
qall.gpor.norand$pred <- predict(glmer0.gpor,type="response")
qall.gpor.norand$resid<- resid(glmer0.gpor)

# plot residuals by expert and question to check for evidence of non-independence
pr_nr_1<-ggplot(qall.dfus.norand, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() +geom_point()+ggtitle('dfus') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.dfus.norand$expert_ID-9]))+facet_grid(.~question, scales="free")
pr_nr_2<-ggplot(qall.gpor.norand, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() +geom_point()+ggtitle('ebis') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.gpor.norand$expert_ID-9]))+facet_grid(.~question, scales="free")
pr_nr_3<-ggplot(qall.ebis.norand, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() +geom_point()+ggtitle('gpor') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.ebis.norand$expert_ID-9]))+facet_grid(.~question, scales="free")
pr_nr_4<-ggplot(qall.ecir.norand, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() +geom_point()+ggtitle('ecir') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.ecir.norand$expert_ID-9]))+facet_grid(.~question, scales="free")

grid.arrange(pr_nr_1, pr_nr_3, pr_nr_2, pr_nr_4)

# plot residuals by expert to check for evidence of non-independence
pr_nr_1b<-ggplot(qall.dfus.norand, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() +geom_point()+ggtitle('dfus') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.dfus.norand$expert_ID-9]))
pr_nr_2b<-ggplot(qall.gpor.norand, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() +geom_point()+ggtitle('ebis') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.gpor.norand$expert_ID-9]))
pr_nr_3b<-ggplot(qall.ebis.norand, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() +geom_point()+ggtitle('gpor') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.ebis.norand$expert_ID-9]))
pr_nr_4b<-ggplot(qall.ecir.norand, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() +geom_point()+ggtitle('ecir') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.ecir.norand$expert_ID-9]))

grid.arrange(pr_nr_1b, pr_nr_3b, pr_nr_2b, pr_nr_4b)

# plot residuals by expert and region to check for evidence of non-independence
pr_nr_1c<-ggplot(qall.dfus.norand, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() +geom_point()+ggtitle('dfus') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.dfus.norand$expert_ID-9]))+facet_grid(.~region, scales="free")
pr_nr_2c<-ggplot(qall.gpor.norand, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() +geom_point()+ggtitle('ebis') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.gpor.norand$expert_ID-9]))+facet_grid(.~region, scales="free")
pr_nr_3c<-ggplot(qall.ebis.norand, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() +geom_point()+ggtitle('gpor') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.ebis.norand$expert_ID-9]))+facet_grid(.~region, scales="free")
pr_nr_4c<-ggplot(qall.ecir.norand, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() +geom_point()+ggtitle('gpor') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.ecir.norand$expert_ID-9]))+facet_grid(.~region, scales="free")

grid.arrange(pr_nr_1c, pr_nr_3c, pr_nr_2c, pr_nr_4c)


######## glmer1 - with random expert_ID effects (intercept, temp, size^2)
glmer1.dfus<-glmer(cbind(qall.dfus$mean_reaches,qall.dfus$failure_reaches) ~ c.log.drainage + I(c.log.drainage^2) + c.temp + c.flow*c.freq + c.perc.ripa*c.perc.upla + trout_presence + ebis_presence + gpor_presence + (1+c.temp+ I(c.log.drainage^2)|expert_ID),data = qall.dfus,family=binomial)
glmer1.gpor<-glmer(cbind(qall.gpor$mean_reaches,qall.gpor$failure_reaches) ~ c.log.drainage + I(c.log.drainage^2) + c.temp + c.flow+c.freq + c.perc.ripa*c.perc.upla + trout_presence + ebis_presence + dfus_presence + (1+c.temp+ I(c.log.drainage^2)|expert_ID),data = qall.gpor,family=binomial)
glmer1.ebis<-glmer(cbind(qall.ebis$mean_reaches,qall.ebis$failure_reaches) ~ c.log.drainage + I(c.log.drainage^2) + c.temp + c.flow*c.freq + c.perc.ripa*c.perc.upla + trout_presence + dfus_presence + gpor_presence + (1+c.temp+ I(c.log.drainage^2)|expert_ID),data = qall.ebis,family=binomial)
glmer1.ecir<-glmer(cbind(qall.ecir$mean_reaches,qall.ecir$failure_reaches) ~ c.log.drainage + I(c.log.drainage^2) + c.temp + c.flow*c.freq + c.perc.ripa*c.perc.upla + trout_presence + dfus_presence + gpor_presence + (1+c.temp+ I(c.log.drainage^2)|expert_ID),data = qall.ecir,family=binomial)

# save predicted values and residuals for each species
qall.dfus.randex<-qall.dfus
qall.gpor.randex<-qall.gpor
qall.ebis.randex<-qall.ebis
qall.ecir.randex<-qall.ecir
qall.dfus.randex$pred <- predict(glmer1.dfus,type="response")
qall.dfus.randex$resid<- resid(glmer1.dfus)
qall.ebis.randex$pred <- predict(glmer1.ebis,type="response")
qall.ebis.randex$resid<- resid(glmer1.ebis)
qall.ecir.randex$pred <- predict(glmer1.ecir,type="response")
qall.ecir.randex$resid<- resid(glmer1.ecir)
qall.gpor.randex$pred <- predict(glmer1.gpor,type="response")
qall.gpor.randex$resid<- resid(glmer1.gpor)

# plot residuals by expert and question to check for evidence of non-independence
pr_nr_1<-ggplot(qall.dfus.randex, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() +geom_point()+ggtitle('dfus') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.dfus.randex$expert_ID-9]))+facet_grid(.~question, scales="free")
pr_nr_2<-ggplot(qall.gpor.randex, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() +geom_point()+ggtitle('ebis') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.gpor.randex$expert_ID-9]))+facet_grid(.~question, scales="free")
pr_nr_3<-ggplot(qall.ebis.randex, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() +geom_point()+ggtitle('gpor') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.ebis.randex$expert_ID-9]))+facet_grid(.~question, scales="free")
pr_nr_4<-ggplot(qall.ecir.randex, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() +geom_point()+ggtitle('ecir') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.ecir.randex$expert_ID-9]))+facet_grid(.~question, scales="free")

grid.arrange(pr_nr_1, pr_nr_3, pr_nr_2, pr_nr_4)

# plot residuals by expert to check for evidence of non-independence
pr_nr_1b<-ggplot(qall.dfus.randex, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() +geom_point()+ggtitle('dfus') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.dfus.randex$expert_ID-9]))
pr_nr_2b<-ggplot(qall.gpor.randex, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() +geom_point()+ggtitle('ebis') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.gpor.randex$expert_ID-9]))
pr_nr_3b<-ggplot(qall.ebis.randex, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() +geom_point()+ggtitle('gpor') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.ebis.randex$expert_ID-9]))
pr_nr_4b<-ggplot(qall.ecir.randex, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() +geom_point()+ggtitle('ecir') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.ecir.randex$expert_ID-9]))

grid.arrange(pr_nr_1b, pr_nr_3b, pr_nr_2b, pr_nr_4b)

# plot residuals by expert and region to check for evidence of non-independence
pr_nr_1c<-ggplot(qall.dfus.randex, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() +geom_point()+ggtitle('dfus') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.dfus.randex$expert_ID-9]))+facet_grid(.~region, scales="free")
pr_nr_2c<-ggplot(qall.gpor.randex, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() +geom_point()+ggtitle('ebis') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.gpor.randex$expert_ID-9]))+facet_grid(.~region, scales="free")
pr_nr_3c<-ggplot(qall.ebis.randex, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() +geom_point()+ggtitle('gpor') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.ebis.randex$expert_ID-9]))+facet_grid(.~region, scales="free")
pr_nr_4c<-ggplot(qall.ecir.randex, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() +geom_point()+ggtitle('gpor') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.ecir.randex$expert_ID-9]))+facet_grid(.~region, scales="free")

grid.arrange(pr_nr_1c, pr_nr_3c, pr_nr_2c, pr_nr_4c)

# view model results
summary(glmer1.dfus)
summary(glmer1.gpor)
summary(glmer1.ebis)
summary(glmer1.ecir)

# view random effects (intercept)
lattice::dotplot(ranef(glmer1.dfus, condVar=TRUE),layout = c(1,3),title="dfus")
lattice::dotplot(ranef(glmer1.gpor, condVar=TRUE),layout = c(1,3),title="gpor")
lattice::dotplot(ranef(glmer1.ebis, condVar=TRUE),layout = c(1,3),title="ebis")
lattice::dotplot(ranef(glmer1.ecir, condVar=TRUE),layout = c(1,3),title="ecir")

# plot re and fix effects
library(sjPlot)
sjp.glmer(glmer1.dfus,type="fe",show.ci=TRUE,title="dfus-fixed effects",geom.size=2)
sjp.glmer(glmer1.gpor,type="fe",show.ci=TRUE,title="gpor-fixed effects",geom.size=2)
sjp.glmer(glmer1.ebis,type="fe",show.ci=TRUE,title="ebis-fixed effects",geom.size=2)
sjp.glmer(glmer1.ecir,type="fe",show.ci=TRUE,title="ecir-fixed effects",geom.size=2)

sjp.glmer(glmer1.dfus,type="fe.pc",show.ci=TRUE,sort.coef=TRUE)
sjp.glmer(glmer1.dfus,type="eff",show.ci=TRUE,sort.coef=TRUE)
sjp.glmer(glmer1.dfus,type="re",show.ci=TRUE,sort.coef=TRUE)
sjp.glmer(glmer1.dfus,type="ri.pc",show.ci=TRUE,sort.coef=TRUE)


# plot model fit (actual vs. predicted)
p1<-ggplot(qall.dfus.randex, aes(pred,mean_reaches/100), colour="black") + geom_point() + stat_smooth(method="lm") + ggtitle('dfus') + ylab("observed")
p2<-ggplot(qall.gpor.randex, aes(pred,mean_reaches/100), colour="black") + geom_point() + stat_smooth(method="lm") + ggtitle('gpor')+ ylab("observed")
p3<-ggplot(qall.ebis.randex, aes(pred,mean_reaches/100), colour="black") + geom_point() + stat_smooth(method="lm") + ggtitle('ebis')+ ylab("observed")
p3b<-ggplot(qall.ecir.randex, aes(pred,mean_reaches/100), colour="black") + geom_point() + stat_smooth(method="lm") + ggtitle('ecir')+ ylab("observed")

grid.arrange(p1,p2,p3,p3b,ncol=2)

# plot residuals
r1<-ggplot(qall.dfus.randex, aes(pred,resid,color=factor(expert_ID))) + geom_point() + geom_hline(yintercept=0) + ggtitle('dfus')+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.dfus$expert_ID-9]))
r2<-ggplot(qall.gpor.randex, aes(pred,resid,color=factor(expert_ID))) + geom_point() + geom_hline(yintercept=0) + ggtitle('gpor')+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.gpor$expert_ID-9]))
r3<-ggplot(qall.ebis.randex, aes(pred,resid,color=factor(expert_ID))) + geom_point() + geom_hline(yintercept=0) + ggtitle('ebis')+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.ebis$expert_ID-9]))
r4<-ggplot(qall.ecir.randex, aes(pred,resid,color=factor(expert_ID))) + geom_point() + geom_hline(yintercept=0) + ggtitle('ecir')+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.ecir$expert_ID-9]))
grid.arrange(r1,r2,r3,r4, ncol=2)

# plot residuals by question 
p4<-ggplot(qall.dfus.randex, aes(question,resid, fill=factor(question))) + geom_boxplot() + ggtitle('dfus') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.dfus.randex$expert_ID-9]))
p5<-ggplot(qall.gpor.randex, aes(question,resid, fill=factor(question)))+ geom_boxplot() + ggtitle('ebis') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.gpor.randex$expert_ID-9]))
p6<-ggplot(qall.ebis.randex, aes(question,resid, fill=factor(question))) + geom_boxplot() + ggtitle('gpor') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.ebis.randex$expert_ID-9]))
p6b<-ggplot(qall.ecir.randex, aes(question,resid, fill=factor(question))) + geom_boxplot() + ggtitle('gpor') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.ecir.randex$expert_ID-9]))
grid.arrange(p4, p5, p6,p6b)

# plot residuals by expert
p7<-ggplot(qall.dfus.randex, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() + ggtitle('dfus') + geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.dfus.randex$expert_ID-9]))+scale_x_continuous(breaks=unique(qall.dfus$expert_ID))
p8<-ggplot(qall.gpor.randex, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot()  + ggtitle('gpor')+ geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.gpor.randex$expert_ID-9]))+scale_x_continuous(breaks=unique(qall.gpor$expert_ID))
p9<-ggplot(qall.ebis.randex, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() + ggtitle('ebis')+ geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.ebis.randex$expert_ID-9]))+scale_x_continuous(breaks=unique(qall.ebis$expert_ID))
p10<-ggplot(qall.ecir.randex, aes(expert_ID,resid, col=factor(expert_ID))) + geom_boxplot() + ggtitle('ecir')+ geom_hline(yintercept=0)+theme(legend.position="none")+ scale_colour_manual(values=unique(e.color[qall.ecir.randex$expert_ID-9]))+scale_x_continuous(breaks=unique(qall.ecir$expert_ID))
#grid.arrange(p7, p8, p9)
grid.arrange(p7,p8,p9,p10, ncol=2)

# make new df with predicted and residuals 
qall.new<-rbind(qall.dfus.randex,qall.gpor.randex,qall.ebis.randex,qall.ecir.randex)
```
```{r plot predicted values,          echo=FALSE, results='hide'}
library("effects")
par(mfrow=c(2,2))
plot(effect(c("c.log.drainage"),glmer1.dfus),grid=TRUE,se=TRUE)
plot(effect(c("c.log.drainage","I(c.log.drainage^2)"),glmer1.dfus),grid=TRUE,se=TRUE)

grid.arrange(plot(effect(c("c.temp"),glmer1.dfus),grid=TRUE),
plot(effect(c("c.temp"),glmer1.gpor),grid=TRUE),
plot(effect(c("c.temp"),glmer1.ebis),grid=TRUE))

plot(effect(c("(Intercept)"),glmer1.dfus),grid=TRUE)
  
grid.arrange(plot(effect(c("c.flow:c.freq"),glmer1.dfus),grid=TRUE,style="stacked"),
             plot(effect(c("c.flow","c.freq"),glmer1.gpor),grid=TRUE,style="stacked"),
             plot(effect(c("c.flow:c.freq"),glmer1.ebis),grid=TRUE,style="stacked"))

grid.arrange(plot(effect("c.perc.ripa:c.perc.upla",glmer1.dfus,grid=TRUE)),plot(effect("c.perc.ripa:c.perc.upla",glmer1.gpor,grid=TRUE)),plot(effect("c.perc.ripa:c.perc.upla",glmer1.ebis,grid=TRUE)),ncol=3)

grid.arrange(plot(effect("trout_presence",glmer1.dfus,grid=TRUE)),plot(effect("trout_presence",glmer1.gpor,grid=TRUE)),plot(effect("trout_presence",glmer1.ebis,grid=TRUE)),ncol=3)

grid.arrange(
  plot(effect("ebis_presence",glmer1.dfus,grid=TRUE)),
  plot(effect("ebis_presence",glmer1.gpor,grid=TRUE)),
  plot(effect("gpor_presence",glmer1.dfus,grid=TRUE)),
  plot(effect("gpor_presence",glmer1.ebis,grid=TRUE)),
  plot(effect("dfus_presence",glmer1.gpor,grid=TRUE)),
  plot(effect("dfus_presence",glmer1.ebis,grid=TRUE)),ncol=3)


# plot relations between predicted occ and factors
dodge=position_dodge(width=0.5)  

############# predicted stream size
prsize<-ggplot(subset(qall.new,qall.new$question==3),aes(drainage_area_sqkm,pred,col=factor(expert_ID))) + geom_line(size=0.5) + ylim(0,1) + ylab("predicted p(occupancy)")+ xlab("drainage area, km2")+ theme(legend.position="none")+ scale_colour_manual(values=rep("black",length(unique(e.color[qall.new$expert-9]))))+ facet_grid(.~species, scales="free")
prsize

prlsize<-ggplot(subset(qall.new,qall.new$question==3),aes(log(drainage_area_sqkm),pred,col=factor(expert_ID))) + geom_line(size=0.5)+ ylim(0,1) + ylab("predicted p(occupancy)")+ xlab("log(drainage area), km2")+ theme(legend.position="none")+ scale_colour_manual(values=rep("black",length(unique(e.color[qall.new$expert-9]))))+ facet_grid(.~species, scales="free")
prlsize

grid.arrange(prsize,prlsize)

############# predicted stream temp
prtemp<-ggplot(subset(qall.new,qall.new$question==4),aes(summer_temp_C,pred,color=factor(expert_ID),shape=factor(species))) + geom_point(size=0)+ geom_line(size=0.5)+ ylim(0,1) + ylab("predicted p(occupancy)")+ xlab("mean summer temp, C")+theme(legend.position="none")+scale_colour_manual(values=rep("black",length(unique(e.color[qall.new$expert-9]))))+ facet_grid(.~species, scales="free")
prtemp

############# q5 - streamflow
prflow<-ggplot(subset(qall.new,qall.new$question==5),aes(flow_year_freq,pred,col=factor(expert_ID),shape=factor(species))) + geom_point(size=0)+ geom_line(size=0.5) + ylim(0,1) + ylab("predicted prob occupancy")+ xlab("frequency of dry years")+theme(legend.position="none")+scale_colour_manual(values=rep("black",length(unique(e.color[qall.new$expert-9]))))+ facet_grid(flow_type+stream_width_m~.~species, scales="free") 
prflow

############# q6 - forest cover
prfor<-ggplot(subset(qall.new,qall.new$question==6),aes(riparian_forest,pred,shape=factor(expert_ID),color=factor(species))) + geom_point(size=0)+ geom_line(size=0.5) + ylim(0,1) + ylab("predicted prob occupancy")+ xlab("percent riparian")+theme(legend.position="none")+scale_colour_manual(values=rep("black",length(unique(e.color[qall.new$expert-9]))))+ facet_grid(upland_forest~.~species, scales="free") 
prfor

############# q7 - brook trout - need to fix plot
dodge=position_dodge(width=0.5) 
prfish<-ggplot(subset(qall.new,qall.new$question==7),aes(x=expert_ID,y=pred,col=factor(expert_ID))) + geom_point(position=dodge,size=1) + ylim(0,1)+theme(legend.position="none")+scale_colour_manual(values=rep("black",length(unique(e.color[qall.new$expert-9]))))+ facet_grid(trout_presence~.~species, scales="free") 
prfish

dodge=position_dodge(width=0.5) 
p14<-ggplot(subset(qall.new,qall.new$question==7),aes(x=expert_ID,y=pred,col=factor(expert_ID))) + geom_point(position=dodge,size=1) + geom_errorbar(aes(y=mean_reaches/100,ymin=lower_reaches/100, ymax=upper_reaches/100), width=0, position=dodge) + ylim(0,1)  + ggtitle("trout presence") + coord_flip()   
p14

```
```{r export out_betas,               echo=FALSE, results='hide'}
# table of estimates with 95% CI
se.dfus <- sqrt(diag(vcov(glmer1.dfus)))
tab.dfus <- cbind(Est = fixef(glmer1.dfus), LL = fixef(glmer1.dfus) - 1.96 * se.dfus, UL = fixef(glmer1.dfus) + 1.96 * se.dfus)
se.gpor <- sqrt(diag(vcov(glmer1.gpor)))
tab.gpor <- cbind(Est = fixef(glmer1.gpor), LL = fixef(glmer1.gpor) - 1.96 * se.gpor, UL = fixef(glmer1.gpor) + 1.96 * se.gpor)
se.ebis <- sqrt(diag(vcov(glmer1.ebis)))
tab.ebis <- cbind(Est = fixef(glmer1.ebis), LL = fixef(glmer1.ebis) - 1.96 * se.ebis, UL = fixef(glmer1.ebis) + 1.96 * se.ebis)
se.ecir <- sqrt(diag(vcov(glmer1.ecir)))
tab.ecir <- cbind(Est = fixef(glmer1.ecir), LL = fixef(glmer1.ecir) - 1.96 * se.ecir, UL = fixef(glmer1.ecir) + 1.96 * se.ecir)

# create list for betas
betas<-list()
betas$dfus<-summary(glmer1.dfus)
betas$gpor<-summary(glmer1.gpor)
betas$ebis<-summary(glmer1.ebis)
betas.coef<-data.frame(dfus=print(betas$dfus$coefficients[,1:2]),
                       tab.dfus,
                       gpor=print(betas$gpor$coefficients[,1:2]),
                       tab.gpor,
                       ebis=print(betas$ebis$coefficients[,1:2]),
                       tab.ebis)
colnames(betas.coef)<-c("dfus.mean","dfus.stder","dfus.est","dfus.LL","dfus.UL","gpor.mean","gpor.stder","gpor.est","gpor.LL","gpor.UL","ebis.mean","ebis.stder","ebis.est","ebis.LL","ebis.UL")
#predictor.name<-c("int","s.log.sqkm","s.temp","s.temp2","s.flow","s.freq","s.ripa","s.upla","trout","sp1","sp2","s.flowxs.freq","s.ripax.supla")
predictor.name<-c("int","s.log.sqkm","s.temp","s.flow","s.freq","s.ripa","s.upla","trout","sp1","sp2","s.flowxs.freq","s.ripax.supla")
betas.coef$predictor<-predictor.name
betas.coef<-data.frame(betas.coef)

write.csv(betas.coef,file="out_betas.csv",row.names=TRUE)
```
```{r export cov_ranges,              echo=FALSE, results='hide'}

# create list of ranges of covariates (actual and std scales) - need to fix
cov.ranges<-list()
cov.ranges$min<-c(min(qall.data$drainage_area_sqkm),
                  min(qall.data$summer_temp_C),
                  min(qall.data$summer_temp_C^2),
                  min(qall.data$flow_type),
                  min(qall.data$flow_year_freq),
                  min(qall.data$riparian_forest),
                  min(qall.data$upland_forest),
                  min(qall.data$trout_presence),
                  min(qall.data$ebis_presence),
                  min(qall.data$gpor_presence),
                  min(qall.data$flow_year_freq*qall.data$flow_type),
                  min(qall.data$riparian_forest*qall.data$upland_forest))
cov.ranges$max<-c(max(qall.data$drainage_area_sqkm),
                  max(qall.data$summer_temp_C),
                  max(qall.data$summer_temp_C^2),
                  max(qall.data$flow_type),
                  max(qall.data$flow_year_freq),
                  max(qall.data$riparian_forest),
                  max(qall.data$upland_forest),
                  max(qall.data$trout_presence),
                  max(qall.data$ebis_presence),
                  max(qall.data$gpor_presence),
                  max(qall.data$flow_year_freq*qall.data$flow_type),
                  max(qall.data$riparian_forest*qall.data$upland_forest))
cov.ranges$mean<-c(mean(qall.data$drainage_area_sqkm),
                  mean(qall.data$summer_temp_C),
                  mean(qall.data$summer_temp_C^2),
                  mean(qall.data$flow_type),
                  mean(qall.data$flow_year_freq),
                  mean(qall.data$riparian_forest),
                  mean(qall.data$upland_forest),
                  mean(qall.data$trout_presence),
                  mean(qall.data$ebis_presence),
                  mean(qall.data$gpor_presence),
                  mean(qall.data$flow_year_freq*qall.data$flow_type),
                  mean(qall.data$riparian_forest*qall.data$upland_forest))

cov.ranges$sd<-c( sd(qall.data$drainage_area_sqkm),
                  sd(qall.data$summer_temp_C),
                  sd(qall.data$summer_temp_C^2),
                  sd(qall.data$flow_type),
                  sd(qall.data$flow_year_freq),
                  sd(qall.data$riparian_forest),
                  sd(qall.data$upland_forest),
                  sd(qall.data$trout_presence),
                  sd(qall.data$ebis_presence),
                  sd(qall.data$gpor_presence),
                  sd(qall.data$flow_year_freq*qall.data$flow_type),
                  sd(qall.data$riparian_forest*qall.data$upland_forest))
cov.ranges$s.min<-c(
                  min(qall.data$s.area),
                  min(qall.data$s.temp),
                  min(qall.data$s.temp^2),
                  min(qall.data$s.flow),
                  min(qall.data$s.freq),
                  min(qall.data$s.ripa),
                  min(qall.data$s.upla),
                  min(qall.data$s.fish),
                  min(qall.data$s.ebis),
                  min(qall.data$s.gpor),
                  min(qall.data$s.freq*qall.data$s.flow),
                  min(qall.data$s.ripa*qall.data$s.upla))
cov.ranges$s.max<-c(
                  max(qall.data$s.area),
                  max(qall.data$s.temp),
                  max(qall.data$s.temp^2),
                  max(qall.data$s.flow),
                  max(qall.data$s.freq),
                  max(qall.data$s.ripa),
                  max(qall.data$s.upla),
                  max(qall.data$s.fish),
                  max(qall.data$s.ebis),
                  max(qall.data$s.gpor),
                  max(qall.data$s.freq*qall.data$s.flow),
                  max(qall.data$s.ripa*qall.data$s.upla))
cov.ranges$s.mean<-c(
                  mean(qall.data$s.area),
                  mean(qall.data$s.temp),
                  mean(qall.data$s.temp^2),
                  mean(qall.data$s.flow),
                  mean(qall.data$s.freq),
                  mean(qall.data$s.ripa),
                  mean(qall.data$s.upla),
                  mean(qall.data$s.fish),
                  mean(qall.data$s.ebis),
                  mean(qall.data$s.gpor),
                  mean(qall.data$s.freq*qall.data$s.flow),
                  mean(qall.data$s.ripa*qall.data$s.upla))
cov.ranges$s.sd<-c(
                  sd(qall.data$s.area),
                  sd(qall.data$s.temp),
                  sd(qall.data$s.temp^2),
                  sd(qall.data$s.flow),
                  sd(qall.data$s.freq),
                  sd(qall.data$s.ripa),
                  sd(qall.data$s.upla),
                  sd(qall.data$s.fish),
                  sd(qall.data$s.ebis),
                  sd(qall.data$s.gpor),
                  sd(qall.data$s.freq*qall.data$s.flow),
                  sd(qall.data$s.ripa*qall.data$s.upla))
cov.ranges<-as.data.frame(cov.ranges)
colnames(cov.ranges)<-c("min.cov","max.cov","mean.cov","sd.cov","min.scov","max.scov","mean.scov","sd.scov")
predictor.name<-c("log.drainage","temp","temp2","freq","flow","riparian","upland","trout","sp1","sp2","freq.flow","ripa.upla")
cov.ranges$predictor<-predictor.name
write.csv(cov.ranges,file="out_cov_ranges.csv",row.names=TRUE)
```
```{r plot betas,                     echo=FALSE,result='hide'}
str(betas.coef)

betas.est<-c(betas.coef[1:12,"dfus.est"],betas.coef[1:12,"gpor.est"],betas.coef[1:12,"ebis.est"])
betas.ll<-c(betas.coef[1:12,"dfus.LL"],betas.coef[1:12,"gpor.LL"],betas.coef[1:12,"ebis.LL"])
betas.ul<-c(betas.coef[1:12,"dfus.UL"],betas.coef[1:12,"gpor.UL"],betas.coef[1:12,"ebis.UL"])
betas.sp<-c(rep("dfus",12),rep("gpor",12),rep("ebis",12))
#predictor.name<-c("int","s.log.sqkm","s.temp","s.temp2","s.flow","s.freq","s.ripa","s.upla","trout","sp1","sp2","s.flowxs.freq","s.ripax.supla")
predictor.name<-c("int","s.log.sqkm","s.temp","s.flow","s.freq","s.ripa","s.upla","trout","sp1","sp2","s.flowxs.freq","s.ripax.supla")
betas.name<-c(rep(predictor.name,3))
all.betas<-data.frame(betas.est,betas.ll,betas.ul,betas.sp,betas.name)
str(all.betas)

dodge=position_dodge(width=0.3)  
p20<-ggplot(all.betas,aes(y=betas.est,x=betas.name,col=factor(betas.sp),stat="identity")) + geom_point(position=dodge,size=1,stat="identity") + geom_errorbar(aes(y=betas.mean,ymin=betas.ll,ymax=betas.ul),size=.5,position=dodge,width=0) + coord_flip()    
p20

sjp.lmer(glmer1.dfus)

```

#################### predict occupancy using expert data and sheds covariates
```{r standarize cov.df for predictions,        echo=FALSE, results='hide',eval=FALSE}
# import cov_ranges
covrange.data<-read.csv("/Users/katz-umass/github_folder/Trout_Salamander_Decisions/Expert_Elicitation/salamander_elicitation_model/out_cov_ranges.csv",fill=TRUE,header=TRUE)
covrange.data

# import betas
beta.data<-read.csv("/Users/katz-umass/github_folder/Trout_Salamander_Decisions/Expert_Elicitation/salamander_elicitation_model/out_betas.csv",fill=TRUE,header=TRUE)
beta.data

# look at covariates for deerfield catchments
cov.df

# standardize covariates based on mean and sd from cov_ranges - need to fix
cov.area.std<-(cov.df$area-covrange.data[covrange.data$predictor=="log.drainage","mean.cov"])/covrange.data[covrange.data$predictor=="log.drainage","sd.cov"]
cov.temp.std<-(cov.df$temp-covrange.data[covrange.data$predictor=="temp","mean.cov"])/covrange.data[covrange.data$predictor=="temp","sd.cov"]
cov.temp2.std<-(cov.df$temp2-covrange.data[covrange.data$predictor=="temp2","mean.cov"])/covrange.data[covrange.data$predictor=="temp2","sd.cov"]
cov.upla.std<-(cov.df$ufor-covrange.data[covrange.data$predictor=="upland","mean.cov"])/covrange.data[covrange.data$predictor=="upland","sd.cov"]
cov.ripa.std<-(cov.df$rfor-covrange.data[covrange.data$predictor=="riparian","mean.cov"])/covrange.data[covrange.data$predictor=="riparian","sd.cov"]
cov.upla.ripa.std<-cov.upla.std*cov.ripa.std
```

```{r predict pocc deerfield,   echo=FALSE, results='hide', eval=FALSE}
# create new matrix of std.covariates
#cov.df.std<-cbind(log(cov.area.std+1))
#cov.std.m<-cbind(cov.temp.std)
#cov.std.m<-cbind(cov.temp2.std)
#cov.std.m<-cbind(cov.temp.std,cov.temp2.std)
#cov.std.m<-cbind(cov.upla.std)
#cov.std.m<-cbind(cov.ripa.std,cov.upla.std,cov.ripa.upla.std)

cov.std.m<-cbind(cov.area.std,cov.ripa.std,cov.upla.std)
cov.std.m<-as.matrix(cov.std.m,ncols=3,nrows=985)
str(cov.std.m)

cov.std.m<-cbind(log(cov.area.std+1),cov.temp.std,cov.temp2.std,cov.ripa.std,cov.upla.std,cov.ripa.std*cov.upla.std)
cov.std.m<-as.matrix(cov.std.m,ncols=5,nrows=985)
str(cov.std.m)

# create a vector of betas for each species
dfus.betas<-c(beta.data$dfus.mean[2:4],beta.data$dfus.mean[7:8])
dfus.betas<-c(beta.data$dfus.mean[2:4],beta.data$dfus.mean[7:8])
dfus.betas<-c(beta.data$dfus.mean[7:8])
dfus.betas<-c(beta.data$dfus.mean[2],beta.data$dfus.mean[7:8])
#,beta.data$defu.mean[6],beta.data$defu.mean[5])
dfus.betas<-c(beta.data$dfus.mean[2:4],beta.data$dfus.mean[7:8],beta.data$dfus.mean[13])
ebis.betas<-c(beta.data$ebis.mean[2:4],beta.data$ebis.mean[7:8])
ebis.betas<-c(beta.data$ebis.mean[7:8])
ebis.betas<-c(beta.data$ebis.mean[2],beta.data$ebis.mean[7:8])
#,beta.data$eubi.mean[6],beta.data$eubi.mean[5])
ebis.betas<-c(beta.data$ebis.mean[2:4],beta.data$ebis.mean[7:8],beta.data$ebis.mean[13])
gpor.betas<-c(beta.data$gpor.mean[2:4],beta.data$gpor.mean[7:8])
gpor.betas<-c(beta.data$gpor.mean[7:8])
gpor.betas<-c(beta.data$gpor.mean[2],beta.data$gpor.mean[7:8])
#,beta.data$gypo.mean[6],beta.data$gypo.mean[5])
gpor.betas<-c(beta.data$gpor.mean[2:4],beta.data$gpor.mean[7:8],beta.data$gpor.mean[13])

# calculate probability of occupancy using logit link function
logit.p.dfus<- beta.data$dfus.mean[1] + rowSums(cov.std.m * dfus.betas)  
pr_occ.dfus<-1/(1+exp(-(logit.p.dfus)))
logit.p.ebis<- beta.data$ebis.mean[1] + rowSums(cov.std.m * ebis.betas)   
pr_occ.ebis<-1/(1+exp(-(logit.p.ebis)))
logit.p.gpor<- beta.data$gpor.mean[1] + rowSums(cov.std.m * gpor.betas)   
pr_occ.gpor<-1/(1+exp(-(logit.p.gpor)))

# wrong intercept? try setting intercept to "region" mean
str(qall.new)
int<-list() # intercept from question 2
int$dfus<-subset(qall.new,question=="2"&species=="dfus")
int$gpor<-subset(qall.new,question=="2"&species=="ebis")
int$ebis<-subset(qall.new,question=="2"&species=="ebis")
median(int$dfus$logit.p)

# calculate pr_occ
p.dfus<- plogis(beta.data$dfus.mean[1] + rowSums(cov.std.m * dfus.betas)) 
p.gpor<- plogis(beta.data$gpor.mean[1] + rowSums(cov.std.m * gpor.betas)) 
p.ebis<- plogis(beta.data$ebis.mean[1] + rowSums(cov.std.m * ebis.betas)) 

cov.df$dfus_pr_occ<-p.dfus
cov.df$ebis_pr_occ<-p.ebis
cov.df$gpor_pr_occ<-p.gpor
plot(cov.df$dfus_pr_occ)
plot(cov.df$ebis_pr_occ)
plot(cov.df$gpor_pr_occ)

h1<-ggplot(cov.df,aes(dfus_pr_occ))+ylim(0,50)+geom_histogram(bins=100)
h2<-ggplot(cov.df,aes(gpor_pr_occ))+ylim(0,50)+geom_histogram(bins=100)
h3<-ggplot(cov.df,aes(ebis_pr_occ))+ylim(0,50)+geom_histogram(bins=100)
grid.arrange(h1,h2,h3,ncol=3)
require(lattice)
cloud(dfus_pr_occ~ebis_pr_occ*gpor_pr_occ,data=cov.df)
cloud(gpor_pr_occ~dfus_pr_occ*ebis_pr_occ,data=cov.df)

p21.dfus<-ggplot(cov.df,aes(ufor,dfus_pr_occ)) + geom_point() + xlab("percent upland forest")
p21.ebis<-ggplot(cov.df,aes(ufor,ebis_pr_occ)) + geom_point() + xlab("percent upland forest")
p21.gpor<-ggplot(cov.df,aes(ufor,gpor_pr_occ)) + geom_point() + xlab("percent upland forest")
grid.arrange(p21.dfus,p21.ebis,p21.gpor)

p22.dfus<-ggplot(cov.df,aes(rfor,dfus_pr_occ)) + geom_point() + xlab("percent riparian forest")
p22.ebis<-ggplot(cov.df,aes(rfor,ebis_pr_occ)) + geom_point() + xlab("percent riparian forest")
p22.gpor<-ggplot(cov.df,aes(rfor,gpor_pr_occ)) + geom_point() + xlab("percent riparian forest")
grid.arrange(p22.dfus,p22.ebis,p22.gpor)

cloud(dfus_pr_occ~ufor*rfor,data=cov.df)

p23.dfus<-ggplot(cov.df,aes(area,dfus_pr_occ)) + geom_point() + xlab("drainage area (stream size)")
p23.ebis<-ggplot(cov.df,aes(area,ebis_pr_occ)) + geom_point() + xlab("drainage area (stream size)")
p23.gpor<-ggplot(cov.df,aes(area,gpor_pr_occ)) + geom_point() + xlab("drainage area (stream size)")
grid.arrange(p23.dfus,p23.ebis,p23.gpor)

p24.dfus<-ggplot(cov.df,aes(temp,dfus_pr_occ)) + geom_point() + xlab("summer temp, C")
p24.ebis<-ggplot(cov.df,aes(temp,ebis_pr_occ)) + geom_point() + xlab("summer temp, C")
p24.gpor<-ggplot(cov.df,aes(temp,gpor_pr_occ)) + geom_point() + xlab("summer temp, C")
grid.arrange(p24.dfus,p24.ebis,p24.gpor)
```
```{r predict pocc ct,          echo=FALSE, results='hide', eval=FALSE}
```

```{r export out_pocc (mean, min, max, var), echo=FALSE, results='hide', eval=FALSE}
# export predicted occupancy to plot in GIS
library(foreign)
write.dbf(cov.df,file="out_mean_salpocc_deerfield.dbf")
```

#################### make some maps 










